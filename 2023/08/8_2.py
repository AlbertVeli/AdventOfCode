#!/usr/bin/env python3

import sys
sys.path.append('../..')
import aoc
import re
import math

lines = aoc.lines(sys.argv[1])

lr = lines[0]
d = dict()
for line in lines[2:]:
    strings = re.findall(r'[A-Z0-9]+', line)
    d[strings[0]] = (strings[1], strings[2])

length = len(lr)

# Start nodes end with 'A'
starts = []
for k in d.keys():
    if k[2] == 'A':
        starts.append(k)
ls = len(starts)

# End nodes end with 'Z'. Assume steps until
# an end node is reached is cyclic. This can
# be empirically verified. Return cycle length.
def cycle_len(node):
    i = 0
    while True:
        t = d[node]
        dir = lr[i % length]
        if dir == 'L':
            node = t[0]
        else:
            node = t[1]
        i = i + 1
        if node[2] == 'Z':
            break
    return i

# lcm function was generated by bing chat,
# but I could have just googled it, baby.
def lcm(numbers):
    return math.lcm(*numbers)

cycles = []
for i in range(ls):
    cycles.append(cycle_len(starts[i]))

# Answer should be least common multiple of
# all cycles, assuming all steps are cyclic.
# Thanks, William!
print('Part 2:', lcm(cycles))